# [8/29] 1주차 - 디프만 콘서트 예매 시스템

생성일: 2025년 8월 17일 오후 10:42

# 디프만 콘서트 예매 시스템

<aside>

한 공연장의 좌석을 온라인으로 판매하려고 한다.
사용자는 좌석 배치를 보고 원하는 좌석을 선택한 뒤 결제할 수 있어야 하며, 이미 판매된 좌석은 다시 판매되면 안된다. 또한 좌석을 고른 뒤 일정 시간 안에 결제를 완료하지 않으면 좌석은 자동으로 풀려야 합니다.

</aside>

### 가정

- 단일 이벤트(공연 1회차)만 다룬다.
- PC 웹 기준(모바일 고려는 선택).
- 외부 결제는 **“결제 성공 콜백이 온다”** 가정(실제 결제 연동은 모의).

## 기능적 요구사항

- 사용자는 해당 페이지에서, 전체 좌석, 열, 그리고 좌석 상태에 대해 조회 할 수 있다.
- 좌석은 **선택 → 결제 → 확정(판매완료)** 의 흐름을 가진다.
- 결제가 완료된 좌석은 다시 판매될 수 없다.
- 사용자는 예매가 완료되기까지 동기적으로 응답을 확인해야 한다.
- 사용자는 자신의 예매 내역을 조회할 수 있다.
- 사용자는 예매가 완료되기까지 대기열에서 대기해야한다.
- 좌석 예매와 관련된 로그를 저장하고 조회해야한다.

## 비기능적 요구사항.

1. **중복 판매가 되어서는 안된다.**
2. 예매가 열리는 순간 피크 사용자가, 20만명 & 전체 좌석은 15,000석이라고 가정.
3. 좌석 조회는 평균 응답시간 <150ms> p95 ~ p99 (하위 5% ~ 하위 1%) 일때
4. 주문 생성 & 좌석 예매까지의 응답시간 <500ms>

---

# ERD 설계

> 설계 과정에서의 고민 지점
> 

![스크린샷 2025-08-28 오후 7.44.33.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.44.33.png)

## 1. 예매(RESARVATION)와 좌석(SEAT) 간의 관계 설계

> **"이 좌석 지금 판매 가능한가?"** 를 빠르고 정확한 판단이 가능해야. 
좌석마다 시간이 흐르면서 여러 상태(대기, 확정, 취소, 만료)를 가질텐데, 확정을 제외하고 
어떤 시점에 해당 좌석을 다시 팔 수 있는 지가 관건.
> 

A. 단일 좌석 예매만 가능한 경우  
`설계` ⇒ 정규화 진행하지 않고, **RESERVATION** 안에 `seat_id` & 예약 상태 모두를 관리
           `seat_id`에 **UNIQUE 제약**을 두어 한 좌석당 동시에 1건만 예약 가능하도록.

장점 : 스키마/쿼리 단순 → 읽기·쓰기 비용 낮고, 트랜잭션 경계가 짧고 명확하다. 
          레코드 락이나 유니크 제약 조건만으로도 DB 레벨에서의 동시성 상황에 대한 제어가 가능하다. 

         20만 동시 사용자라도, 동시에 실제로 INSERT가 시도되는 좌석은 1.5만 중 일부뿐이고,
         각 좌석은 독립적으로 경쟁 → 락 경합이 좌석 단위로 분산된다. 
         DB 입장에서는 `seat_id` 단위의 유니크 충돌만 관리하면 되므로, 구조적 병목이 크지 않음.

단점 : 확장에 닫혀있다. (좌석별 정책이나 아래와 같이 여러 좌석 예매가 가능하도록 요구사항이 변경된다면) 
         또한, 사용자가 여러 좌석 예매가 가능하다면 아예 사용 불가능할 정도.(좌석별로 다른 만료 시간이나 다른             상태를 두기 어려움)

B. 여러 좌석 예매가 가능한 경우
1. `RESERVATION` ↔ `RESERVATION_SEAT`(N:1 매핑) ↔ `SEAT`

장점

- 여러 비즈니스 정책에 대해 유연한 확장이 가능
- 좌석 단위로 상태와 만료 시간에 대해 일관되게 추적 가능 ⇒ **정합성(중복판매 방지) + 가용성 판단**을 단일 로직으로 처리  ⇒ 좌석과 예약 테이블을 직접 들여다 볼 필요가 없다.

단점 

- 트랜잭션에서 좌석 여러 건을 원자적으로 처리, 동시성 제어도 마찬가지로 좌석 단위로 처리
⇒ 트랜잭션 범위가 커짐에 따라 구현상의 복잡도 UP
- 쿼리 수와 조인 복잡도 증가
- 전체 좌석 수 조회를 하는 경우, 좌석 수가 많다면 단일 테이블보다 조회 성능이 느릴 수 있음.
⇒ 현재의 피크로 조회 시, 캐싱이나 인덱스 튜닝이 필요할 것이다.

2. `reservation(id)` + `seat(reservation_id nullable unique)`

좌석이 예약되면 `seat.reservation_id = 예약ID`로 세팅되고,  한 예약이 여러 좌석을 가지면, 여러 `seat` 행이 같은 `reservation_id`를 가지는 형태. 

장점

- **매핑 테이블 없이**도 다대일 표현 가능(JOIN 1번)
- 좌석별 상태/만료를 `SEAT`에 두면 가용성 체크가 빠름
- 좌석당 1행이므로 **중복 판매 방지**를 행 락/유니크로 제어하기 용이

단점 

- SEAT Entity 가 예약 상태와 강하게 결합하여, 상태 변화시 SEAT 업데이트가 수반됨.

⇒ 최소한의 JOIN 으로 조회 성능과 데이터 정합성을 챙기려면 이게 가장 나을 것 같음. (확장의 가능성이 적다면) 

## 2. 만료 처리

DB 컬럼으로 관리 vs 별도 스케줄러 vs Redis TTL ⇒ expires_at (DB 컬럼)과 배치 작업(`expires_at > now()` 조건으로 **즉시 해제)**

### a. DB 컬럼(expires_at) + 스케쥴러 / 배치

: 모든 가용성/판정을 DB에서 `WHERE expires_at > now()` 조건으로 수행. 
  만료가 지나면 “판매 가능”으로 상태 변경.
  배치 스케줄러는 주기적으로 만료된 레코드의 상태를 `EXPIRED`로 정리.

[장점]

- 스케줄러가 아직 만료 처리를 하지 않아도, 조회 쿼리가 `expires_at > now()`를 포함하므로, 만료 시간이 지난 순간부터는 예약이 가능해지게 할 수 있음.
    
    <aside>
    
    ### Lazy Expiration (만료 처리 지연)
    
    : 만료 시간(`expires_at`)만 저장해 두고, 시간이 지났다고 해서 즉시 상태를 바꾸거나 삭제하지 않고 다음에 그 데이터를 조회하거나 접근할 때 비로소 “만료됨”으로 판정하는 방식.
    
    </aside>
    
    ```java
    SELECT *
    FROM reservation_seat
    WHERE seat_id=1
      AND seat_status IN ('HOLD','CONFIRMED')
      AND expires_at > NOW();
    ```
    
    ⇒ 만료시각이 지난 순간부터 조회에서 빠지므로, 사용자는 좌석이 바로 풀린 것처럼 보인다. 
       또한, Redis TTL 과 같은 외부 의존이 없고 높은 정합성을 가진다. 
    

[단점]

- DB 서버 시간 의존도가 크고, 만료된 레코드에 대한 관리가 까다롭다.  
⇒ 이는 배치 스케쥴러를 통해 해결할 수 있음.

## 3. 대기열

### 💥 별도의 테이블로 관리한다면?

> 좌석 예약과 별개의 독립적인 생명주기(입장 대기→활성→만료)를 가져야 한다.
> 

[장점]

- 대기열만의 지표를 운영/모니터링 할 수 있음.
- 대기열 토큰 발급을 통해 보안상의 제어가 가능하고, 예약 플로우와 확실한 분리가 가능하기에 
운영상 용이
- 별도 테이블이기에 추후 캐싱이나 샤딩 같은 확장에 있어서도 열려있는 편

[단점]

- 특정 유저에 대한 대기 여부 조회 쿼리가 많아진다면, JOIN이 필요하다.
- 별도의 테이블이 생김으로써 얻게 되는 운영상의 불편함. (순번 정렬, 대기열 만료) ⇒ 별도의 파이프라인 필요
- 수많은 대기들에 대해 원자적으로 대기 상태값을 일관되게 바꿔줘야 한다. ⇒ 구현 & 트랜잭션 관리 어려움

### 대안1) RESERVATION 에 내장

⇒ JOIN 없고 예약 생성 시점과 동시에 관리가 가능하지만, 대기열이 **예약 생성 이전**에도 존재해야하고 
    아무래도 분리된 형태보다 부하에 약할 것임 ⇒ 작은 서비스에 적합

(같은 맥락으로 USER 에 내장하는 것도, 조회 성능에는 강하겠지만 사용자 엔티티가 세션/대기 상태로 오염될 것)

### 대안2) 인메모리 DB & RDB (런타임 판정/순번은 인메모리, **사후 분석/복구는 DB**로 커버)

⇒ 토큰/순번/만료를 Redis List/Sorted Set + TTL 로 관리
영속성은 없지만, 수십만의 트래픽을 받아서 처리하기엔 최적의 성능과 UX 제공해준다. 
하지만, 장애 발생 시 대기열 자체가 유실될 위험이 크기에 별도의 백업용 영속 DB를 둬, 로그나 스냅샷 저장 

 

---

# 아키텍처 다이어그램 그리기

### [WAS 앞단]

> Client → CDN→ API Gateway → Load Balancer → (각 서비스)
> 
1. CDN (CloudFlare, AWS CloudFront) 

: 모든 정적 컨텐츠를 캐싱하여, 웹사이트 로드 성능 개선이나 좌석 정보 조회 시 속도 개선.
  (정적자원·캐시 가능한 API를 CDN이 대신 서빙하여 오리진 서버 부하 감소)

1. API Gateway

: **처리율 제한**, **인증** 등의 기능을 지원하는 관리형 서비스로, 
  엔드포인트 **기반**으로 특정 서비스에 **요청을 전달**할 수 있도록 구성. 
 `/seats`(읽기), `/reservations`(예약), `/payments`(결제) 등 요청**을 해당 서비스로 분배**.

1. Load Balancer (Nginx/ALB) 

: 아래 서비스의 서버가 여러 개로 확장된다면 ? 
  꼭 트래픽 분산용도로 쓰지 않더라도,  UX 고려해서 다운타임 최소화를 위해 무중단 배포 하려면 필요할 듯 하다. 

### [고민] 서버 를 나눠서 MSA 로 설계 해야할까 ?

1. **부하가 다름**: 좌석 예약(쓰기)은 높음, 콘서트 정보(읽기)는 가벼움 → 독립적으로 운영
2. **장애 전파 막기**: 결제쪽 문제로 예약이 멈추면 안됨 → **결제 따로 격리**
3. **배포 속도 차이**: 콘서트 정보는 자주 바뀜 & 예약/결제 → **릴리즈 주기가 다르다**.

1) **좌석 예약 서비스** (핵심 쓰기 경로) & 예약 전용 DB 

- 역할: 좌석 대기/만료/확정, 중복판매 방지(트랜잭션)
- 부하 검증을 통해 좌석 읽기(캐시)와 쓰기로 작업에 따른 DB 분리도 고려

2) **결제 서비스** (외부 PG 연동 전담) & 결제 전용 DB 

- 역할: 결제 시작/상태 조회, **PG 콜백 수신(멱등·서명 검증)**, 예약 서비스에 “확정” 여부 전달
- 이유: 외부 연동 이슈(콜백 폭주/재시도 등)가 많아 **격리**하는게 안전하다고 판단.

3) **콘서트 서비스(핵심 읽기 경로) & 콘서트 전용 DB**

- 역할: 공연/좌석맵/공지 등 **읽기 위주 API**
- **읽기 전용 인프라 구축** (CDN/Redis/DB Read 레플리카 다층 캐시 적용)

### [고민] 예약 대기열은 어디에 둬야할까 ?

1. WAS 앞단에서의 엣지 대기실 (CDN/CloudFront)
    - 오픈과 동시에 200,000명이 클릭 → 엣지에서 **초당 1,000명만 통과**시킬 수 있음. 
    나머지는 엣지에서 대기 페이지(“잠시만요…”)를 보고 있다가 **순차적으로** 입장하도록 하여 
    WAS 의 부담 최소화
    - 입장 차례가 되면, 엣지가 짧게 유효한 토큰 내려줌 ⇒ 토큰을 붙여 WAS(오리진 서버)로 
    들어오면, API GateWay 에서 검증이 된 유저만 통과
2. WAS 내부에서의 Redis 클러스터 (정렬 Set + TTL)
: 순번 만료나 별도의 토큰 발급을 통해 인증된 사용자만 예약 API 통과가 가능하게 하는 등 
  세밀한 제어용. (단위는 유저 단위 or 세션 단위) 

---

## (Optioanl) 추가 고민해보면 좋을만한 사항들

Q] 동시에 여러 사람이 같은 좌석을 선택하면 어떻게 막을까?

- 트랜잭션 최대한 짧게 잡기 ⇒ 첫 UPDATE 가 레코드 락 선점
- 인당 여러 좌석 예매가 가능하다면, 유저 식별자에 엮인 좌석을 트랜잭션으로 잡아서
하나라도 실패하면 전체 롤백시키는 방향.. (모두가 UPDATE 되어야 예약 확정으로 커밋)
- 좌석이 락(Lock)을 가지게 한다.  ⇒ 조건부 UPDATE 로 선점하는 식으로

Q] 결제 실패/타임아웃이 발생하면 좌석 상태를 어떻게 돌려놓을까?

- `RESERVATION`: `PENDING → (CONFIRMED | FAILED | TIMED_OUT)
SEAT`: `AVAILABLE ↔ LOCKED(hold) → CONFIRMED`
실패/타임아웃이면 **LOCKED 해제 → AVAILABLE**로 복귀
- TTL 로 복구(시간 지나면 조회 시점에서 자동 제외) & 배치로 쿼리 청소
- 별도의 멱등 저장소를 둔다. (`reservation_id + pg_event_id`)
⇒ 콜백이 도착하면 이력 조회하여, 이미 있으면 200 응답 &
    `reservation.status='PENDING'`일 때만 예약 허용

Q] 같은 주문 요청이 여러 번 오면(중복 클릭 등) 어떻게 막을 수 있을까?

- 결제 시 멱등키 강제
: 결제 서버에 항상 같은 식별자 값으로 재시도하도록
- 주문 식별자를 받을때 요청 헤더에 UUID 도 포함하여, 테이블이나 캐시에서 해당 키가 있는지 조회. 
**없다** → 새로 기록: `key=1234, status=PROCESSING` (처리 중 표시) → **실제 주문 처리 시작**
처리 끝나면 `status=DONE`, `response=결과 JSON`으로 **저장** → 그 결과를 사용자에게 응답

Q] 수십만 명이 동시에 접속하면 어떤 부분이 가장 먼저 병목이 될까?
⇒ ‘좌석 맵 조회’ API 경로가 병목이 될 것이다. 
    수십만 명이 들어오면 전부 **좌석 맵부터 봄** → 읽기 트래픽이 쓰기(예약)보다 **압도적으로 많을 것이다.** 

동시 200,000명, `/seats`를 2초마다 새로고침할 경우 ⇒ **100,000 rps** 요청이 생성된다. 
이때, CDN 이나 Redis 같이 읽기 전용 인프라에서 캐시 Miss로 히트율이 떨어진다면, 서버에 가장 먼저 병목이 올 것이고, DB 커넥션도 순식간에 고갈될 것이다.