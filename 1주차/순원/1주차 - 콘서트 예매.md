<img width="962" height="868" alt="image" src="https://github.com/user-attachments/assets/93d842df-f3dc-4591-bf46-b5230d7b7ff1" />

<img width="1332" height="1420" alt="image" src="https://github.com/user-attachments/assets/e8d906dd-505d-4d34-96fe-cfdd7dd4bd1e" />

## 1. 대규모 트래픽 처리 방안

### 고민

- 예매 시작 직후 약 20만 명의 피크 사용자가 동시에 몰릴 때, 시스템이 다운되지 않고 안정적으로 요청을 처리해야 한다.
- 모든 요청을 즉시 처리하려고 하면 서버(CPU, Memory)와 데이터베이스(Connection Pool)에 과부하가 걸려 전체 시스템 장애로 이어질 가능성이 매우 높다.

### 해결

- **대기열(Queue) 시스템 도입**: 실제 서비스 로직에 진입하는 사용자 수를 제어하기 위해 대기열을 도입한다.
- **Redis 기반 구현**: 대기열 관리 도구로 Redis를 선택한다.
- **스케줄러를 통한 활성 사용자 제어**: 주기적으로 실행되는 스케줄러를 통해, 현재 시스템이 감당할 수 있는 만큼의 사용자만 대기열에서 '활성' 상태로 전환하여 서비스 접근을 허용한다.

### 근거

- **왜 대기열인가?**: 요청을 순서대로 쌓아두고 시스템의 처리 용량에 맞게 조금씩 처리함으로써, 순간적인 트래픽 폭증이 시스템 전체 장애로 이어지는 것을 막을 수 있다. 이는 사용자에게 무작정 '서버 에러'를 보여주는 것보다 '현재 n명이 대기 중입니다'와 같은 훨씬 긍정적인 사용자 경험을 제공한다.
- **왜 Redis인가?**
    - **In-Memory**: 메모리 기반으로 동작하여 매우 빠르다.
    - **자료구조**: 대기열 구현에 최적화된 Sorted Set(`ZSET`)과 같은 강력한 자료구조를 제공한다. Sorted Set을 사용하면 대기 순서(시간 순)에 따른 정렬과 조회가 매우 효율적이다.
    - **확장성 및 안정성**: 모든 서버가 하나의 Redis를 바라보는 중앙 집중식 구조를 통해, 서버를 여러 대로 확장(Scale-out)하더라도 대기열의 일관성을 유지할 수 있다. 또한, 데이터 영속성 옵션을 통해 서버 재시작 시에도 대기열 정보를 보존할 수 있다.
- **왜 스케줄러인가?**: 스케줄러는 시스템의 '문지기(Gatekeeper)' 역할을 한다. 현재 시스템에 접속해 있는 '활성' 사용자 수를 주기적으로 체크하고, 여유가 생길 때마다 대기열에서 다음 사용자를 입장시킨다. 이 메커니즘이 없다면, 대기열에 있는 모든 사용자가 동시에 서비스 접근을 시도하여 대기열 도입의 의미가 없어진다. 즉, 스케줄러는 시스템의 처리량을 일정하게 유지하는 핵심 장치이다.

---

## 2. 좌석 동시 예약 문제 처리

### 고민

- 여러 사용자가 거의 동시에 동일한 좌석에 대해 예약을 시도할 경우, 중복 예약(Double Booking)이 발생해서는 안 된다.
- 좌석의 상태를 '예약 가능'에서 '예약 중'으로 변경하는 과정은 반드시 원자적(Atomic)으로 처리되어야 한다.

### 해결

- **데이터베이스의 비관적 락(Pessimistic Lock) 사용**
    - `SeatRepository`에서 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 어노테이션을 사용하여 특정 좌석 조회 시 데이터베이스에 쓰기 락(exclusive lock)을 거는 메서드(`findByIdForUpdate`)를 구현한다.
    - `reserveSeat` 로직 안에서 이 메서드를 호출하여, 좌석의 상태를 확인하고 변경하는 전체 과정을 하나의 트랜잭션 안에서 원자적으로 처리한다.

### 근거

- **`synchronized`의 한계 극복**: `synchronized`는 단일 서버 환경에서만 유효하며, 서버를 여러 대로 확장하는 분산 환경에서는 동시성을 보장할 수 없다. 비관적 락은 데이터베이스가 락을 관리하므로, 여러 서버에서 동시에 요청이 들어와도 데이터의 일관성을 보장할 수 있어 확장성이 뛰어나다.
- **데이터 정합성 보장**: `SELECT ... FOR UPDATE` 구문을 통해 트랜잭션이 끝날 때까지 다른 트랜잭션이 해당 데이터에 접근하는 것을 막는다. 이는 '조회'와 '수정' 사이의 시간차로 인해 발생할 수 있는 경쟁 상태(Race Condition)를 원천적으로 차단하여 데이터 정합성을 강력하게 보장한다. 충돌이 빈번하게 발생할 것으로 예상되는 좌석 선점과 같은 시나리오에 매우 적합하다.
- **구현의 명확성**: Spring Data JPA의 `@Lock` 어노테이션을 사용하면 복잡한 락킹 로직을 선언적으로 간단하게 구현할 수 있다.

---

## 3. 임시 예약 만료 처리 (결제 타임아웃)

### 고민

- 사용자가 좌석을 임시 예약(선점)한 후, 정해진 시간(예: 5분) 내에 결제를 완료하지 않으면 해당 좌석은 다른 사용자를 위해 다시 '예약 가능' 상태가 되어야 한다.
- 만료된 예약을 자동으로 정리하고 좌석을 풀어주는 메커니즘이 없다면, 소수의 사용자가 많은 좌석을 선점만 하고 결제하지 않는 경우 실제 구매를 원하는 다른 사용자들이 피해를 보게 된다. 이는 판매 기회의 손실로 이어진다.

### 해결

- **스케줄러를 이용한 일괄 처리(Batch Job)**
    - `ReservationScheduler`라는 별도의 스케줄러를 구현한다.
    - 이 스케줄러는 정해진 주기(예: 1분)마다 실행된다.
    - 실행될 때마다, 현재 시간을 기준으로 만료 시간이 지났지만 여전히 '결제 대기중'(`PENDING`) 상태인 모든 예약을 데이터베이스에서 조회한다.
    - 조회된 예약들의 상태를 '만료'(`EXPIRED`)로 변경하고, 해당 예약에 연결된 좌석의 상태를 다시 '예약 가능'(`AVAILABLE`)으로 업데이트한다.
    - 이 모든 과정은 단일 트랜잭션으로 묶어 데이터 정합성을 보장한다.

### 근거

- **왜 스케줄러인가?**: 각 예약의 만료 시간을 개별적으로 추적하여 이벤트를 발생시키는 방식은 구현이 복잡하고 시스템에 부하를 줄 수 있다. 반면, 스케줄러를 이용해 주기적으로 만료된 예약을 찾아 일괄 처리하는 방식은 구현이 간단하고 시스템 부하가 적다. 트래픽이 적은 새벽 시간에 실행하는 등 유연한 운영도 가능하다.
- **데이터베이스 조회 최적화**: `Reservation` 테이블의 `status`와 `expiresAt` 컬럼에 적절한 인덱스(복합 인덱스)를 생성하면, 만료된 예약을 조회하는 쿼리의 성능을 크게 향상시킬 수 있다. 이를 통해 스케줄러가 실행될 때 데이터베이스에 주는 부하를 최소화할 수 있다.
- **안정성**: 스케줄러가 특정 주기에 실패하더라도, 다음 주기에 다시 실행되어 처리되지 못했던 만료 건들을 처리할 수 있으므로 시스템의 안정성을 높일 수 있다.

---

## 4. 활성 사용자 처리량 최적화

### 고민

- 사용자가 예매 및 결제를 모두 완료했음에도 불구하고, 할당된 대기열 토큰의 유효시간(예: 5분)이 끝날 때까지 '활성 사용자' 슬롯을 계속 점유하는 문제가 있었다.
- 이로 인해 실제 활동중인 사용자가 없음에도 활성 사용자 수는 줄어들지 않았고, 대기열에 있는 다음 사용자가 서비스에 진입하지 못하고 무기한 대기하게 되는 심각한 처리량(Throughput) 저하 문제가 발생할 수 있다.

### 해결

- **명시적 토큰 만료 처리**: 사용자가 시스템의 핵심적인 최종 과업(여기서는 '결제')을 완료하는 시점에, 해당 사용자의 대기열 토큰을 즉시 만료 처리하는 로직을 추가한다.
    - `PaymentService`의 `processPayment` 메서드 마지막에, 결제가 성공적으로 완료되면 `QueueTokenService`를 호출하여 현재 사용자의 토큰을 즉시 `EXPIRED` 상태로 변경하고, '활성 사용자' 집합(`queue:active`)에서도 제거한다.

## 4-2. 대기열 근본 문제점 분석

**대기열의 본래 목적**: 순간적인 트래픽 폭증(20만명 동시 접속)을 분산시켜 시스템 안정성을 확보하는 것

**현재 설계의 문제**:

- 사용자가 결제를 완료할 때까지 활성 슬롯을 점유
- 결제는 보통 2-3분 소요되는데, 이 시간 동안 다른 사용자들이 무의미하게 대기
- 실제로는 **조회 트래픽**만 분산시키면 되는데, **전체 예매 프로세스**를 통제하고 있음

## 더 합리적인 접근법

```yaml
시나리오 1: 현재 방식 (비효율적)
- 활성 사용자 100명 제한
- 대기열 101번째부터는 3분 추가 대기

시나리오 2: 개선된 방식 (효율적)  
- 예) 1초마다 50명씩 입장 허용
- 좌석 조회/선택 후 바로 슬롯 반납
- 선점된 좌석으로 결제 진행 (대기열과 무관)
- 훨씬 빠른 회전율로 더 많은 사용자 처리 가능
```

## 개선 방향

1. **활성 사용자 정의 변경**: "현재 좌석을 조회/선택 중인 사용자"로 한정
2. **슬롯 반납 시점 앞당기기**: 좌석 선점 완료 시점에 즉시 반납
3. **결제는 별도 프로세스**: 선점된 좌석 정보로 독립적으로 진행

---

## ❓다른 사람들 발표를 듣고 생긴 질문

<aside>
💡

유니크 제약조건을 베이스로 낙관적 락을 왜 쓰는 거지? 유니크 제약조건만으로 충분하잖아?

</aside>

유니크 제약조건(Unique Constraint)은 **데이터의 유일성을 보장**하지만, **낙관적 락은 동시성 환경에서 데이터의 무결성을 보장**합니다. 이 둘은 다른 문제를 해결하기 때문에 상호 보완적으로 사용됩니다.


### 유니크 제약조건의 한계

유니크 제약조건은 데이터베이스 레벨에서 '중복 데이터 삽입'을 막는 데 매우 효과적입니다. 하지만 다음과 같은 상황에는 대응하기 어렵습니다.

1. **동시에 같은 행을 업데이트하는 경우**: 두 사용자가 동시에 동일한 재고 수량을 100에서 90으로 업데이트하려고 합니다. 유니크 제약조건은 이 경우에 충돌을 감지하지 못합니다. 먼저 커밋한 트랜잭션의 변경사항이 나중에 커밋한 트랜잭션에 의해 덮어쓰여 **데이터가 유실될 수 있습니다.** 이 문제를 "Lost Update(갱신 손실)"라고 부릅니다.
2. **비즈니스 로직의 복잡성**: 유니크 제약조건은 단순히 값의 중복 여부만 확인합니다. 예를 들어, 재고를 업데이트할 때 `현재 재고 - 구매 수량`을 계산해야 하는 비즈니스 로직은 제약조건만으로 처리할 수 없습니다.


### 낙관적 락의 역할

낙관적 락은 이러한 **갱신 손실(Lost Update) 문제를 해결**하기 위해 사용됩니다. 주로 `version` 컬럼을 사용해 애플리케이션 레벨에서 충돌을 감지하고 제어합니다.

1. **충돌 감지 및 제어**: 낙관적 락은 업데이트를 시도할 때 **데이터를 처음 읽었을 때의 `version` 값과 현재 `version` 값을 비교**합니다. 만약 두 값이 다르면 다른 트랜잭션이 그 사이에 데이터를 변경했다는 뜻이므로 업데이트를 실패시키고 예외를 발생시킵니다.
2. **데이터 무결성 보장**: 이 충돌 처리 방식을 통해 **동시성 환경에서도 갱신 손실 없이 데이터의 무결성을 지킬 수 있습니다.**

---

### 결론: 콘서트 예매에서는 갱신 손실을 걱정할 필요없으므로, 바로 에러 뱉는 유니크로 충분

- **유니크 제약조건**: `INSERT`나 `UPDATE` 시 **값의 중복을 막는** 데 특화되어 있습니다.
- **낙관적 락**: `UPDATE` 시 **데이터 갱신 손실을 막는** 데 특화되어 있습니다.
