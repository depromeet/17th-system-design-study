# [10/10] 4주차 - 무한 댓글 시스템 설계하기

생성일: 2025년 10월 9일 오후 2:03

## 무한 대댓글 시스템

## 개요:

사용자가 게시글과 같은 데이터에 댓글을 달 수 있습니다. 그리고 댓글에 댓글을 달수있습니다. 그리고 대댓글에 또 대댓글을 달 수 있어요. 이런식으로 댓글에 대댓글을 달 수 있는 구조입니다.

## 기능적 요구 사항

- 사용자는 게시글에 댓글을 달 수 있다.
- 댓글에는 단순 텍스트만 포함 된다고 가정
- 아래와 같은 형식으로 구성이 된다.

```
- 댓글 1
	- 댓글 2
		- 댓글 3
			- 댓글 5
			- 댓글 6
			- 댓글 7
			- 댓글 8
				- 댓글 9
					- 댓글 10
						- 댓글 11
		- 댓글 4
		- 댓글 8
	- 댓글 12
	- 댓글 13
- 댓글 14
```

- 대댓글은 페이지네이션이 되어야 한다.
- 댓글 구조가 위와 같을때 10개 기준으로 페이징을 한다면 댓글 11번까지 첫번째 페이징이 된다고 고려
- 1페이지에는 11번 댓글까지 존재한다.
- 2페이지 에는 댓글 4번 부터 나머지 댓글이 노출

## 비기능적 요구 사항

- 1 페이지에 대한 응답속도 300ms 이내

[Data Modeling — Designing Facebook style “comments” with SQL](https://nehajirafe.medium.com/data-modeling-designing-facebook-style-comments-with-sql-4cf9e81eb164)

---

```sql
CREATE TABLE Comment (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  post_id BIGINT NOT NULL,
  **parent_id** BIGINT NULL,         -- 부모 댓글 id(삽입 O(1))
  **path** VARCHAR(512) NOT NULL,    -- "1/3/8" 같은 계층 경로
  **depth** INT NOT NULL DEFAULT 0,  -- 댓글 깊이
  **position** INT NOT NULL DEFAULT 0,  -- 같은 부모 내 순서 
  body TEXT,
  created_at DATETIME
);

CREATE INDEX idx_comment_post_path ON Comment (post_id, path);
CREATE INDEX idx_comment_parent ON Comment (parent_id);
```

**Materialized Path + 인접 리스트 구조(parent_id)**를 기반으로 경로 문자열(Path)을 함께 저장하여, 대댓글 구조를 표현하였다. 
 

| **id** | **body** | **parent_id** | **depth** | **position** | **path** |
| --- | --- | --- | --- | --- | --- |
| 1 | 댓글1 | NULL | 0 | 1 | 1 |
| 2 | 댓글2 | 1 | 1 | 1 | 1/2 |
| 3 | 댓글3 | 1 | 1 | 2 | 1/3 |
| 4 | 댓글4 | 2 | 2 | 1 | 1/2/4 |

```java
댓글1 (id=1)
 ├── 댓글2 (id=2)
 │     └── 댓글4 (id=4)
 └── 댓글3 (id=3)
```

**parent_id**는 **부모 댓글의 id**로 ****해당 값이 NULL이면 게시글에 직접 달린 최상위 댓글, 값이 있다면 대댓글에 해당한다. 
**각 댓글(row)는 자신의 부모 댓글 ID를 저장**하게 되므로, 부모 → 자식 관계가 ID를 통해 위와 같이
연결된 리스트 형태로 표현된다.

**path**는 **해당 댓글이 루트로부터 어떤 경로로 도달했는지를 기록한 값**이다. 위의 `1/2/4`의 경우 댓글1 → 댓글2 → 댓글4 를 의미하기에, 댓글의 ‘**위치’**를 한눈에 알 수 있다. 덕분에 재**귀 없이도 트리를 한 번에 빠르게 탐색이 가능**하다.

```sql
-- 특정 게시글의 전체 댓글 트리 조회
SELECT * FROM Comment WHERE post_id = 1 ORDER BY path;

-- 특정 댓글(예: 2번) 이하 모든 대댓글 조회
SELECT * FROM Comment WHERE path LIKE '1/2/%';
```

위와 같이 `path` 를 기준으로 정렬하면 부모→자식 순서가 자동으로 맞춰지고, LIKE 검색으로 특정 댓글의 하위 트리를 JOIN 없이 불러올 수 있다. 
인덱스 (post_id, path)를 설정했기에, ‘1/2/%’처럼 prefix 기준으로 인덱스 탐색이 가능하여, 빠른 조회 성능 확보가 가능하다.

**depth**는 댓글의 계층 깊이를 나타내며, UI 상에서는 이 값을 이용해 댓글을 들여쓰기 처리할 수 있다.
쿼리 보다는 UI나 비즈니스 로직에서 주로 사용된다. 

```sql
depth=0 → 댓글1  
  depth=1 → 댓글2  
    depth=2 → 댓글4  
  depth=1 → 댓글3
```

> **댓글 추가 시**
> 

```sql
// 1. 부모가 없는 경우 (최상위 댓글, path = 1)
INSERT INTO Comment (post_id, body, path, depth)
VALUES (1, '댓글1', '1', 0);

// 2. 부모가 있는 경우 (대댓글) 
// 새 댓글을 먼저 INSERT
INSERT INTO Comment (post_id, parent_id, body, path, depth)
VALUES (1, 부모댓글id, '~~', '', 1);

SET @parent_path = (SELECT path FROM Comment WHERE id = 1);

UPDATE Comment
SET path = CONCAT(@parent_path, '/', id)
WHERE id = 2;
```

대댓글의 경우 
부모 댓글의 경로 뒤에, 새 댓글의 ID를 이어붙여서 `path`를 만든다. 자식의 path는 1/~~/자식댓글ID가 될 것이다. 

1. 부모 댓글의 `path`를 조회
2. 새 댓글을 INSERT (DB가 id 생성)
3. 새 댓글의 `path = 부모.path + '/' + id` 로 UPDATE

물론 이 과정은 쿼리보다 코드 레벨에서 진행하여 트랜잭션 처리를 하는게 덜 복잡할 수 있겠다. 

**ex) 댓글 추가 예시**

| id | body | parent_id | path | depth |
| --- | --- | --- | --- | --- |
| 1 | 댓글1 | NULL | `1` | 0 |
| 2 | 댓글2 | 1 | `1/2` | 1 |
| 3 | 댓글3 | 1 | `1/3` | 1 |
| 4 | 댓글4 | 2 | `1/2/4` | 2 |
| 5 | 댓글5 | 2 | `1/2/5` | 2 |
| 6 | 댓글6 | 3 | `1/3/6` | 2 |
| 7 | 댓글7 | 3 | `1/3/7` | 2 |
| 8 | 댓글8 | 6 | `1/3/6/8` | 3 |
| 9 | 댓글9 | NULL | `9` | 0 |
| 10 | 댓글10 | 9 | `9/10` | 1 |

```sql
댓글1 (id=1)
 ├── 댓글2 (id=2)
 │     ├── 댓글4 (id=4)
 │     └── **댓글5 (id=5)**
					 └── **New 댓글**
 └── 댓글3 (id=3)
       ├── 댓글6 (id=6)
       │     └── 댓글8 (id=8)
       └── 댓글7 (id=7)

댓글9 (id=9)
 └── 댓글10 (id=10)
```

새로운 대댓글은 **댓글5** 밑에 달린다고 하자.

```sql
SET @parent_path = (SELECT path FROM Comment WHERE id = 5);
```

부모 댓글(5)의 path를 가져온다. `@parent_path = '1/2/5'` 가 된다. 

```sql
UPDATE Comment
SET path = CONCAT(@parent_path, '/', id)
WHERE id = 새로운 댓글id;
```

결과적으로 새 댓글의 `path`는 `'1/2/5/새로운 댓글id'` 가 되게 된다. 

> 특정 댓글 이하(서브트리) 조회
> 

```sql
SELECT *
FROM Comment
WHERE post_id = :postId
  AND path LIKE CONCAT(:parentPath, '/%')
ORDER BY path;
```

> **페이징은 어떻게 ?**
> 

<aside>

[요구사항]

- 대댓글은 페이지네이션이 되어야 한다.
- 댓글 구조가 위와 같을때 10개 기준으로 페이징을 한다면 댓글 11번까지 첫번째 페이징이 된다고 고려
- 1페이지에는 11번 댓글까지 존재한다.
- 2페이지 에는 댓글 4번 부터 나머지 댓글이 노출
</aside>

```
- 댓글1 (depth=0)
  ├─ 댓글2 (depth=1)
  │   ├─ 댓글3 (depth=2)
  │   │   ├─ 댓글5 (depth=3)
  │   │   ├─ 댓글6 (depth=3)
  │   │   ├─ 댓글7 (depth=3)
  │   │   ├─ 댓글8 (depth=3)
  │   │   │   └─ 댓글9 (depth=4)
  │   │   │        └─ 댓글10 (depth=5)
  │   │   │             └─ 댓글11 (depth=6)
  │   ├─ 댓글4 (depth=2)
  │   ├─ 댓글8 (depth=2)   
  ├─ 댓글12 (depth=1)
  └─ 댓글13 (depth=1)
- 댓글14 (depth=0)
```

```sql
// 1페이지
SELECT * FROM Comment
WHERE post_id = :postId
ORDER BY path
LIMIT :pageSize;

// 2페이지
SELECT * FROM Comment
WHERE post_id = :postId
  AND path > :lastPath
ORDER BY path
LIMIT :pageSize;
```

| id | body | parent_id | path | depth |
| --- | --- | --- | --- | --- |
| 1 | 댓글1 | NULL | 1 | 0 |
| 2 | 댓글2 | 1 | 1/2 | 1 |
| 3 | 댓글3 | 2 | 1/2/3 | 2 |
| 4 | 댓글4 | 2 | 1/2/4 | 2 |
| 8 | 댓글8 | 2 | 1/2/8 | 2 |
| 5 | 댓글5 | 3 | 1/2/3/5 | 3 |
| 6 | 댓글6 | 3 | 1/2/3/6 | 3 |
| 7 | 댓글7 | 3 | 1/2/3/7 | 3 |
| 9 | 댓글9 | 8 | 1/2/8/9 | 3 |
| 10 | 댓글10 | 9 | 1/2/8/9/10 | 4 |
| 11 | 댓글11 | 10 | 1/2/8/9/10/11 | 5 |
| 12 | 댓글12 | 1 | 1/12 | 1 |
| 13 | 댓글13 | 1 | 1/13 | 1 |
| 14 | 댓글14 | NULL | 14 | 0 |

위에서 진행한 `ORDER BY path` 를 통해 댓글의 **계층 순서를 정렬**할 수 있다. 
위 정렬 순서가 곧 트리 순서로, 페이징을 하더라도 트리 구조는 깨지지 않는다.

```sql
// 1페이지 (첫 호출)
SELECT * 
FROM Comment
WHERE post_id = 1
ORDER BY path
LIMIT 10;
```

```sql
// 2페이지 조회하는 경우, 이전 페이지의 마지막 path를 커서로 사용하게 된다.
SELECT *
FROM Comment
WHERE post_id = 1
  AND path > '1/2/8/9/10/11'
ORDER BY path
LIMIT 10;
```

**커서 기반 페이지네이션(`path > :lastPath`)**은 **정렬 기준 필드 자체를 커서(=포인터)로 사용**하게 된다.
이 경우 `path`가 정렬 기준이므로, 마지막으로 본 댓글의 **path**를 기억한다.

기존에 1페이지의 마지막 댓글 path가 `'1/2/8/9/10/11'`이었다면, 그걸 커서로 기억해두고 위와 같이 조건절로 가져온다.

<aside>

> **대규모 환경에서의 path 기반 정렬**
> 

depth가 얕고 댓글도 수십~수백개 수준이라면, 위 표기 방식은 문제가 없다. 
하지만, 대규모 트리일수록 정렬 시 문제가 생길 수 있다. 

DB는 문자열을 사전순으로 정렬하기에, 숫자 길이가 달라지면 문자열 정렬 순서가 깨질 수 있다.

```sql
1/1/1
1/1/10   ← 얘가 1/1/2보다 먼저 옴
1/1/2
```

따라서, 패딩을 추가하면 DB가 문자열을 비교해도 숫자 순서와 문자열 순서가 일치한다. 

```sql
1/2/10 => 0001/0002/0010
```

</aside>

<aside>

> **❗ 만약 댓글15가 1페이지의 마지막인 댓글11에 달리게 된다면,** `path > :lastPath` **이 어떻게 동작할까 ?**
> 

새로운 댓글 15는 부모 path 뒤에 id가 붙으므로, **`path = ‘1/2/8/9/10/11/15`**’ 이다. 
따라서 path > :lastPath 를 만족하기에, 자동으로 2페이지에 들어가게 된다.  

**DB 정렬 상** 새 댓글이 2페이지로 밀려나지만, **트리 관점에선 댓글 15는 11의 자식이므로 1페이지에 속해야** 한다.
이 부분은 DB레벨에서보다 프론트 뷰에서 후처리하는 방식으로 이루어진다고 한다. 

정리하면, 커서 기반(`path > :lastPath`)은 트리의 순서 전체를 커서로 삼기에, 
새 댓글이 추가되어도, 자동으로 기존 페이지 순서를 깨지지 않고 댓글 트리 구조를 보존할 수 있다. 

</aside>